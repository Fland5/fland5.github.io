<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN,en,default">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon48.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16.png?v=7.1.1">


  <link rel="mask-icon" href="/images/favicon48.png?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="面向对象的三大特征 封装把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的信息进行隐藏。 继承对象的继承关系代表了一种‘is a’的关系，比如A和B，可以描述为‘B是A’，表明B继承A。 多态接口的多种不同的实现方式即为多态。  面向对象和面向过程的区别面向过程： 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发">
<meta name="keywords" content="Java,面试">
<meta property="og:type" content="article">
<meta property="og:title" content="不只是简单的Java面试知识点汇总">
<meta property="og:url" content="http://www.fland5.com/2020/04/18/不只是简单的Java面试知识点汇总/index.html">
<meta property="og:site_name" content="Fland&#39;s blog">
<meta property="og:description" content="面向对象的三大特征 封装把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的信息进行隐藏。 继承对象的继承关系代表了一种‘is a’的关系，比如A和B，可以描述为‘B是A’，表明B继承A。 多态接口的多种不同的实现方式即为多态。  面向对象和面向过程的区别面向过程： 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.fland5.com/images/yihuo.png">
<meta property="og:image" content="http://www.fland5.com/images/collectionFrame.png">
<meta property="og:image" content="http://www.fland5.com/images/hashMapDataStructure.png">
<meta property="og:image" content="http://www.fland5.com/images/threadPoolWorkActivity.png">
<meta property="og:image" content="http://www.fland5.com/images/springMVCWorkActivity.png">
<meta property="og:image" content="http://www.fland5.com/images/aopComprehend.png">
<meta property="og:image" content="http://www.fland5.com/images/whyTransactionPropagation.png">
<meta property="og:image" content="http://www.fland5.com/images/transactionPic.png">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-51f17c109ecd6d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-ede8cb7124cbe302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-20378fb6e090d348.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-ce716f6d0eaa805b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-0804d33e42177d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-c8c3922adc477ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-3585c42e9e9a5775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-512f974be2bc4e00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-0ecfa37339642367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-bf0354c0a8ec9766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-b9d3858789d6c2cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-4e31ae1172b3d21e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/15728924-f45dab1125d8c380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2020-04-26T15:11:51.775Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="不只是简单的Java面试知识点汇总">
<meta name="twitter:description" content="面向对象的三大特征 封装把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的信息进行隐藏。 继承对象的继承关系代表了一种‘is a’的关系，比如A和B，可以描述为‘B是A’，表明B继承A。 多态接口的多种不同的实现方式即为多态。  面向对象和面向过程的区别面向过程： 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发">
<meta name="twitter:image" content="http://www.fland5.com/images/yihuo.png">





  
  
  <link rel="canonical" href="http://www.fland5.com/2020/04/18/不只是简单的Java面试知识点汇总/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>不只是简单的Java面试知识点汇总 | Fland's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Fland's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">welcome</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  

  

  <a href="https://github.com/fland5" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.fland5.com/2020/04/18/不只是简单的Java面试知识点汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Fland.Ho">
      <meta itemprop="description" content="target.">
      <meta itemprop="image" content="/images/p.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Fland's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">不只是简单的Java面试知识点汇总

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-04-18 23:30:00" itemprop="dateCreated datePublished" datetime="2020-04-18T23:30:00+08:00">2020-04-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-26 23:11:51" itemprop="dateModified" datetime="2020-04-26T23:11:51+08:00">2020-04-26</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2020/04/18/不只是简单的Java面试知识点汇总/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/04/18/不只是简单的Java面试知识点汇总/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2020/04/18/不只是简单的Java面试知识点汇总/" class="leancloud_visitors" data-flag-title="不只是简单的Java面试知识点汇总">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><ul>
<li>封装<br>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的信息进行隐藏。</li>
<li>继承<br>对象的继承关系代表了一种‘is a’的关系，比如A和B，可以描述为‘B是A’，表明B继承A。</li>
<li>多态<br>接口的多种不同的实现方式即为多态。</li>
</ul>
<h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><h5 id="面向过程："><a href="#面向过程：" class="headerlink" title="面向过程："></a>面向过程：</h5><ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
<h5 id="面向对象："><a href="#面向对象：" class="headerlink" title="面向对象："></a>面向对象：</h5><ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
<li>缺点：性能比面向过程低</li>
</ul>
<h3 id="Java代码的运行"><a href="#Java代码的运行" class="headerlink" title="Java代码的运行"></a>Java代码的运行</h3><p>源代码-&gt;<strong>编译器</strong>将源代码编译为字节码-&gt;<strong>JVM（Java虚拟机） 解释器</strong>将字节码解释为可执行的二进制机器码-&gt;程序运行</p>
<h3 id="JDK与JRE"><a href="#JDK与JRE" class="headerlink" title="JDK与JRE"></a>JDK与JRE</h3><p>JDK是Sun Microsystems针对Java开发人员发布的免费软件开发工具包（SDK，Software development kit）。除JRE（Java Runtime Environment），也就是Java运行环境外还包含提供给开发者使用的javac（编译器）、jar（打包器）、javadoc（文档生成器）等工具包。</p>
<h3 id="重载（overloading）与重写（overriding）"><a href="#重载（overloading）与重写（overriding）" class="headerlink" title="重载（overloading）与重写（overriding）"></a>重载（overloading）与重写（overriding）</h3><ul>
<li>重载<ol>
<li>是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li>
<li>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</li>
<li>最常用的地方就是构造器的重载。</li>
</ol>
</li>
<li>重写<ol>
<li>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。</li>
<li>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。<br>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或对象操作，对不可信的信息进行隐藏。</li>
</ol>
</li>
</ul>
<h3 id="equals与-的区别"><a href="#equals与-的区别" class="headerlink" title="equals与==的区别"></a>equals与==的区别</h3><ul>
<li>对于字符串变量来说，使用“==”和“equals()”方法比较字符串时，其比较方法不同。“==”比较两个变量本身的值，即两个对象在内存中的首地址。“equals()”比较字符串中所包含的内容是否相同。</li>
<li>对于非字符串变量来说，”==”和”equals”方法的作用是相同的都是用来比较其对象在堆内存的首地址，即用来比较两个引用变量是否指向同一个对象。</li>
</ul>
<h3 id="String、StringBuff、StringBuild的区别"><a href="#String、StringBuff、StringBuild的区别" class="headerlink" title="String、StringBuff、StringBuild的区别"></a>String、StringBuff、StringBuild的区别</h3><ul>
<li>String类保存字符串的方式为：private final char value[]，所以string对象不可变。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中保存字符串的方式为char[] value，所以StringBuilder对象与StringBuilder对象可变。</li>
<li>String是常量，线程安全。StringBuff，对调用方法加了同步锁（synchronized）因此线程安全，StringBuild，未加锁因此线程不安全。</li>
<li>String改变会生成新的String对象，相对效率较低，StringBuff与StringBuild改变不会产生新的对象，并且StringBuild未加锁，因此效率最高，但是可能存在线程安全的问题。操作少量数据时，使用String对象，操作大量数据，单线程时使用StringBuild，多线程时使用StringBuff。</li>
</ul>
<h3 id="类成员访问修饰符"><a href="#类成员访问修饰符" class="headerlink" title="类成员访问修饰符"></a>类成员访问修饰符</h3><table>
<thead>
<tr>
<th>访问修饰符</th>
<th style="text-align:center">同一个类</th>
<th style="text-align:center">同包</th>
<th style="text-align:center">不同包，子类</th>
<th style="text-align:center">不同包，非子类</th>
</tr>
</thead>
<tbody>
<tr>
<td>private</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>protected</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>public</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>默认</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="”static”关键字是什么意思？Java中是否可以覆盖-override-一个static方法？"><a href="#”static”关键字是什么意思？Java中是否可以覆盖-override-一个static方法？" class="headerlink" title="”static”关键字是什么意思？Java中是否可以覆盖(override)一个static方法？"></a>”static”关键字是什么意思？Java中是否可以覆盖(override)一个static方法？</h3><p>“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。</p>
<h3 id="Java语言支持的8中基本数据类型对应的长度、对应的包装类"><a href="#Java语言支持的8中基本数据类型对应的长度、对应的包装类" class="headerlink" title="Java语言支持的8中基本数据类型对应的长度、对应的包装类"></a>Java语言支持的8中基本数据类型对应的长度、对应的包装类</h3><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>长度(字节)</th>
<th>包装类</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>1</td>
<td>Boolean</td>
<td>false</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
<td>Byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>Character</td>
<td>‘/uoooo’(null)</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>Short</td>
<td>(short)0</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>Integer</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>Long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>Float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>Double</td>
<td>0.0d</td>
</tr>
</tbody>
</table>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li>类可以实现多个接口，但只能继承一个抽象类</li>
<li>接口中所有的方法都是抽象的。而抽象类则可以包含非抽象的方法。</li>
<li>都不可被实例化，但抽象类如果包含main方法是可以被调用的。</li>
</ul>
<h3 id="final、finally、finalize"><a href="#final、finally、finalize" class="headerlink" title="final、finally、finalize"></a>final、finally、finalize</h3><ul>
<li>final: 常量声明。final类无法继承，final方法无法重写，final值无法改变。 </li>
<li>finally: 处理异常。 不管有无异常都会执行的块，关闭连接通常在其中完成。</li>
<li>finalize: 帮助进行垃圾回收。finalize()方法在一个对象被销毁和回收前会被调用。</li>
</ul>
<h3 id="native方法是什么？"><a href="#native方法是什么？" class="headerlink" title="native方法是什么？"></a>native方法是什么？</h3><p>native方法是非Java代码实现的方法。</p>
<h3 id="如何原地交换两个变量的值？"><a href="#如何原地交换两个变量的值？" class="headerlink" title="如何原地交换两个变量的值？"></a>如何原地交换两个变量的值？</h3><ol>
<li>加减法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 5,b = 10;</span><br><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>同理可用乘除法。<br>注意类型范围，防止溢出。</p>
<ol start="2">
<li>异或法<br><img src="/images/yihuo.png" alt><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 5,b = 10;</span><br><span class="line">a = a ^ b;//1111 = 101 ^ 1010;</span><br><span class="line">b = b ^ a;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="用最有效率的方法计算-2-乘以-8"><a href="#用最有效率的方法计算-2-乘以-8" class="headerlink" title="用最有效率的方法计算 2 乘以 8"></a>用最有效率的方法计算 2 乘以 8</h3><p>2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<h3 id="集合框架中的泛型有什么优点？"><a href="#集合框架中的泛型有什么优点？" class="headerlink" title="集合框架中的泛型有什么优点？"></a>集合框架中的泛型有什么优点？</h3><p>Java1.5 引入了泛型，所有的集合接口和实现都大量地使用它。泛型允许我们为集合提供一个可以容纳的对象类型。因此，如果你添加其它类型的任何元素，它会在编译时报错。这避免了在运行时出现 ClassCastException，因为你将会在编译时得到报错信息。泛型也使得代码整洁，我们不需要使用显式转换和 instanceOf 操作符。它也给运行时带来好处，因为不会产生类型检查的字节码指令。</p>
<h3 id="Java-集合框架的基础接口有哪些？"><a href="#Java-集合框架的基础接口有哪些？" class="headerlink" title="Java 集合框架的基础接口有哪些？"></a>Java 集合框架的基础接口有哪些？</h3><ul>
<li>Collection 为集合层级的根接口。一个集合代表一组对象，这些对象即为它的元素。Java 平台不提供这个接口任何直接的实现。</li>
<li>Set 是一个不能包含重复元素的集合。这个接口对数学集合抽象进行建模，被用来代表集合，就如一副牌。</li>
<li>List 是一个有序集合，可以包含重复元素。你可以通过它的索引来访问任何元素。List 更像长度动态变换的数组。</li>
<li>Map 是一个将 key 映射到 value 的对象。一个 Map 不能包含重复的 key，每个 key 最多只能映射一个 value。尽管 Map 接口和它的实现也是集合框架的一部分，但 Map 不是集合，集合也不是 Map。因此，Map 继承 Collection 毫无意义，反之亦然。如果 Map 继承 Collection 接口，那么元素去哪儿？Map 包含key-value 对，它提供抽取 key 或 value 列表集合的方法，但是它不适合“一组对象”规范。</li>
<li>一些其它的接口有 Queue、Dequeue、SortedSet、SortedMap 和 ListIterator。<br><img src="/images/collectionFrame.png" alt="集合框架图"></li>
</ul>
<h3 id="Iterator-和-ListIterator-的区别是什么？"><a href="#Iterator-和-ListIterator-的区别是什么？" class="headerlink" title="Iterator 和 ListIterator 的区别是什么？"></a>Iterator 和 ListIterator 的区别是什么？</h3><ul>
<li>Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List。</li>
<li>Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。</li>
<li>ListIterator 实现了 Iterator 接口，并包含其他的功能。比如：增加元素，替换元素，获取前一个和后一个元素的索引等等。</li>
</ul>
<h3 id="Java-中的-HashMap-的工作原理是什么？"><a href="#Java-中的-HashMap-的工作原理是什么？" class="headerlink" title="Java 中的 HashMap 的工作原理是什么？"></a>Java 中的 HashMap 的工作原理是什么？</h3><p><img src="/images/hashMapDataStructure.png" alt="HashMap数据结构"><br>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。</p>
<h3 id="HashMap-和-HashTable-有什么区别？"><a href="#HashMap-和-HashTable-有什么区别？" class="headerlink" title="HashMap 和 HashTable 有什么区别？"></a>HashMap 和 HashTable 有什么区别？</h3><ul>
<li>HashMap 是非线程安全的，HashTable 是线程安全的。</li>
<li>HashMap 的键和值都允许有 null 值存在，而 HashTable 则不行。</li>
<li>因为线程安全的问题，HashMap 效率比 HashTable 的要高。</li>
<li>HashTable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li>
<li>一般现在不建议用 HashTable，一是 HashTable 是遗留类，内部实现很多没优化和冗余。二是即使在多线程环境下，现在也有同步的 ConcurrentHashMap 替代，没有必要因为是多线程而用 HashTable。</li>
</ul>
<h3 id="ConcurrentHashMap的并发度是什么？"><a href="#ConcurrentHashMap的并发度是什么？" class="headerlink" title="ConcurrentHashMap的并发度是什么？"></a>ConcurrentHashMap的并发度是什么？</h3><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是ConcurrentHashMap类构造函数的一个可选参数，ConcurrentHashMap的并发度就是segment的大小，默认值为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这样在多线程情况下就能避免争用。</p>
<h3 id="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><a href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？" class="headerlink" title="快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"></a>快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</h3><ul>
<li>快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个 ConcurrentModification 异常。 在 java.util 包下的都是快速失败。</li>
<li>安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出 ConcurrentModification 异常。在java.util.concurrent 包下的全是安全失败的。</li>
</ul>
<h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><ul>
<li>值传递<br>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。我们可以来看下面的一个例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Break &#123;</span><br><span class="line">	public static void change(int a) &#123;</span><br><span class="line">		a = 1;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int a = 2;</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		change(a);</span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>输出结果是： 2 2<br>这个只是传递一份拷贝，和a的值没有什么关系，也可以看成是方法change的值没有一个变量来接收。</p>
<ul>
<li>引用传递<br>对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Break &#123;</span><br><span class="line">	public static void change(int[] a) &#123;</span><br><span class="line">		a[0] = 3;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int[] a = &#123;1, 2&#125;;</span><br><span class="line">		System.out.println(a[0]);</span><br><span class="line">		change(a);</span><br><span class="line">		System.out.println(a[0]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>输出结果是： 1 3<br>这个传递的，就是实际传递的是引用的地址值。所以a[0]的值会改变。</p>
<h3 id="什么是线程？线程和进程区别在哪？"><a href="#什么是线程？线程和进程区别在哪？" class="headerlink" title="什么是线程？线程和进程区别在哪？"></a>什么是线程？线程和进程区别在哪？</h3><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。<br>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。</p>
<h3 id="Java中用到的线程调度算法是什么？"><a href="#Java中用到的线程调度算法是什么？" class="headerlink" title="Java中用到的线程调度算法是什么？"></a>Java中用到的线程调度算法是什么？</h3><p>抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<h3 id="如何实现多线程？"><a href="#如何实现多线程？" class="headerlink" title="如何实现多线程？"></a>如何实现多线程？</h3><p>java.lang.Thread 类的实例就是一个线程，但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口，所以你可以继承java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。</p>
<h3 id="用Thread还是用Runnable？"><a href="#用Thread还是用Runnable？" class="headerlink" title="用Thread还是用Runnable？"></a>用Thread还是用Runnable？</h3><p>大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好了。</p>
<h3 id="Thread-类中的start-和-run-方法有什么区别？"><a href="#Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="Thread 类中的start() 和 run() 方法有什么区别？"></a>Thread 类中的start() 和 run() 方法有什么区别？</h3><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启动，start()方法才会启动新线程。</p>
<h3 id="Runnable和Callable有什么不同？"><a href="#Runnable和Callable有什么不同？" class="headerlink" title="Runnable和Callable有什么不同？"></a>Runnable和Callable有什么不同？</h3><p>使用ExecutorService、Callable、Future可以实现有返回结果的多线程。<br>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<h3 id="常用线程池"><a href="#常用线程池" class="headerlink" title="常用线程池"></a>常用线程池</h3><ol>
<li>newCachedThreadPool创建一个可缓存线程池程</li>
<li>newFixedThreadPool 创建一个定长线程池</li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行</li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池<br><img src="/images/threadPoolWorkActivity.png" alt="线程池工作流程图.png"></li>
</ol>
<h3 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h3><ul>
<li>sleep是Thread线程类的方法，而wait是Object顶级类的方法。</li>
<li>sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用。</li>
<li>sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行。</li>
<li>sleep需要捕获或者抛出异常，而wait/notify/notifyAll不需要。</li>
</ul>
<h3 id="如何强制启动一个线程？"><a href="#如何强制启动一个线程？" class="headerlink" title="如何强制启动一个线程？"></a>如何强制启动一个线程？</h3><p>这个问题就像是如何强制进行Java垃圾回收，目前还没有可靠方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<h3 id="volatile关键字的作用是什么？"><a href="#volatile关键字的作用是什么？" class="headerlink" title="volatile关键字的作用是什么？"></a>volatile关键字的作用是什么？</h3><ul>
<li>多线程使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。</li>
<li>Java代码执行中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率。</li>
</ul>
<h3 id="什么是乐观锁和悲观锁？"><a href="#什么是乐观锁和悲观锁？" class="headerlink" title="什么是乐观锁和悲观锁？"></a>什么是乐观锁和悲观锁？</h3><ol>
<li>乐观锁：对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-设置这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。</li>
<li>悲观锁：对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，直接对操作资源上了锁。</li>
</ol>
<h3 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h3><ul>
<li><p>共享锁【S锁，MyISAM 叫做读锁】<br>又称读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table lock in share mode</span><br></pre></td></tr></table></figure>
</li>
<li><p>排他锁【X锁，MyISAM 叫做写锁】<br>数据库的增删改操作默认都会加排他锁，而查询不会加任何锁。<br>又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table for update</span><br></pre></td></tr></table></figure>
</li>
<li><p>计划锁</p>
</li>
<li>意向锁<ul>
<li>意向共享锁</li>
<li>意向排它锁</li>
</ul>
</li>
</ul>
<h3 id="可重入锁、可中断锁、公平锁、读写锁"><a href="#可重入锁、可中断锁、公平锁、读写锁" class="headerlink" title="可重入锁、可中断锁、公平锁、读写锁"></a>可重入锁、可中断锁、公平锁、读写锁</h3><ol>
<li>可重入锁实际是指锁的分配机制：基于线程的分配，而不是基于方法调用的分配。synchronized和Lock都具备可重入性。</li>
<li>可中断锁，顾名思义，就是可以相应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</li>
<li>公平锁即尽量以请求锁的顺序来获取锁。在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</li>
<li>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。</li>
</ol>
<h3 id="表锁、页锁、行锁"><a href="#表锁、页锁、行锁" class="headerlink" title="表锁、页锁、行锁"></a>表锁、页锁、行锁</h3><p>在 Mysql 中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql 语句操作了主键索引，Mysql 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。<br>InnoDB 行锁是通过给索引项加锁实现的，如果没有索引，InnoDB 会通过隐藏的聚簇索引来对记录加锁。也就是说：如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。因为没有了索引，找到某一条记录就得扫描全表，要扫描全表，就得锁定表。</p>
<h3 id="synchronized与lock的区别"><a href="#synchronized与lock的区别" class="headerlink" title="synchronized与lock的区别"></a>synchronized与lock的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">    void lock(); //用来获取锁。如果锁已被其他线程获取，则进行等待。</span><br><span class="line">    void lockInterruptibly() throws InterruptedException;//当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程。</span><br><span class="line">    boolean tryLock();//方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</span><br><span class="line">    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;//和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</span><br><span class="line">    void unlock();//解锁</span><br><span class="line">    Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。</li>
</ol>
<h4 id="在静态方法和非静态方法上加-Synchronized的区别"><a href="#在静态方法和非静态方法上加-Synchronized的区别" class="headerlink" title="在静态方法和非静态方法上加 Synchronized的区别"></a>在静态方法和非静态方法上加 Synchronized的区别</h4><ul>
<li>Synchronzied 修饰非静态方法==》对象锁。</li>
<li>Synchronzied 修饰静态方法==》其实是类锁，因为是静态方法，它把整个类锁起来了； </li>
</ul>
<h3 id="jdk1-8新特性"><a href="#jdk1-8新特性" class="headerlink" title="jdk1.8新特性"></a>jdk1.8新特性</h3><ul>
<li>Lambda表达式</li>
<li>函数式接口</li>
<li>方法引用和构造器调用</li>
<li>Stream API</li>
<li>接口中的默认方法和静态方法</li>
<li>新时间日期API</li>
</ul>
<h3 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h3><ol>
<li><p>二分查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static int binSearch(int srcArray[], int key) &#123;</span><br><span class="line">	int mid = srcArray.length / 2;</span><br><span class="line">	if (key == srcArray[mid]) &#123;</span><br><span class="line">		return mid;</span><br><span class="line">	&#125;</span><br><span class="line">	int start = 0;</span><br><span class="line">	int end = srcArray.length - 1;</span><br><span class="line">	while (start &lt;= end) &#123;</span><br><span class="line">		mid = (end - start) / 2 + start;</span><br><span class="line">		if (key &lt; srcArray[mid]) &#123;</span><br><span class="line">			end = mid - 1;</span><br><span class="line">		&#125; else if (key &gt; srcArray[mid]) &#123;</span><br><span class="line">			start = mid + 1;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			return mid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>冒泡排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void bubbleSort(int srcArray[]) &#123;</span><br><span class="line">　　　　for (int i = 0; i &lt; srcArray.length - 1; i++) &#123;//外层循环控制排序趟数</span><br><span class="line">　　　　　　for (int j = 0; j &lt; srcArray.length - 1 - i; j++) &#123;//内层循环控制每一趟排序多少次</span><br><span class="line">　　　　　　　　if (srcArray[j] &gt; srcArray[j + 1]) &#123;</span><br><span class="line">　　　　　　　　　　int temp = srcArray[j];</span><br><span class="line">　　　　　　　　　　srcArray[j] = srcArray[j + 1];</span><br><span class="line">　　　　　　　　　　srcArray[j + 1] = temp;</span><br><span class="line">　　　　　　　　&#125;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>快速排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static void quickSort(int[] arr, int low, int high) &#123;</span><br><span class="line">				int i, j, temp, t;</span><br><span class="line">				if (low &gt; high) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				i = low;</span><br><span class="line">				j = high;</span><br><span class="line">				//temp就是基准位</span><br><span class="line">				temp = arr[low];</span><br><span class="line"></span><br><span class="line">				while (i &lt; j) &#123;</span><br><span class="line">					//先看右边，依次往左递减</span><br><span class="line">					while (temp &lt;= arr[j] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">						j--;</span><br><span class="line">					&#125;</span><br><span class="line">					//再看左边，依次往右递增</span><br><span class="line">					while (temp &gt;= arr[i] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">						i++;</span><br><span class="line">					&#125;</span><br><span class="line">					//如果满足条件则交换</span><br><span class="line">					if (i &lt; j) &#123;</span><br><span class="line">						t = arr[j];</span><br><span class="line">						arr[j] = arr[i];</span><br><span class="line">						arr[i] = t;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				//最后将基准为与i和j相等位置的数字交换</span><br><span class="line">				arr[low] = arr[i];</span><br><span class="line">				arr[i] = temp;</span><br><span class="line">				//递归调用左半数组</span><br><span class="line">				quickSort(arr, low, j - 1);</span><br><span class="line">				//递归调用右半数组</span><br><span class="line">				quickSort(arr, j + 1, high);</span><br><span class="line">			&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h3><p>数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式）。</p>
<ol>
<li>线性表<ol>
<li>数组<br>采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n)。</li>
<li>链表<br>对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n)。</li>
</ol>
</li>
<li>栈与队列</li>
<li>树与二叉树<ol>
<li>树</li>
<li>二叉树基本概念</li>
<li>二叉查找树</li>
<li>平衡二叉树</li>
<li>红黑树<br>对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。</li>
</ol>
</li>
<li>Hash表<br>在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。<br>哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法。</li>
</ol>
<h3 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h3><ol>
<li><p>单例模式<br>单例设计模式简单说就是无论程序如何运行，采用单例设计模式的类（Singleton类）永远只会有一个实例化对象产生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">	private Singleton() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static class SingletonHolder &#123;</span><br><span class="line">		private final static Singleton instance = new Singleton();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static Singleton getInstance() &#123;</span><br><span class="line">		return SingletonHolder.instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>工厂模式<br>程序在接口和子类之间加入了一个过渡端，通过此过渡端可以动态取得实现了共同接口的子类实例化对象。</p>
</li>
<li>代理模式<br>指由一个代理主题来操作真实主题，真实主题执行具体的业务操作，而代理主题负责其他相关业务的处理。比如生活中的通过代理访问网络，客户通过网络代理连接网络（具体业务），由代理服务器完成用户权限和访问限制等与上网相关的其他操作（相关业务）。</li>
</ol>
<h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><ul>
<li>对称加密：<br>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。<br>常用对称加密算法：AES、IDEA</li>
<li>非对称加密：<br>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。<br>常用非对称加密算法：RSA、ElGamal</li>
</ul>
<h3 id="何谓RESTful？"><a href="#何谓RESTful？" class="headerlink" title="何谓RESTful？"></a>何谓RESTful？</h3><p>RESTful（Representational State Transfer）架构风格，是一个Web自身的架构风格，底层主要基于HTTP协议（ps:提出者就是HTTP协议的作者），是分布式应用架构的伟大实践理论。RESTful架构是无状态的，表现为请求-响应的形式，有别于基于Bower的SessionId不同。</p>
<h3 id="何谓MVC？"><a href="#何谓MVC？" class="headerlink" title="何谓MVC？"></a>何谓MVC？</h3><ul>
<li>MVC是Model—View—Controler的简称，即模型—视图—控制器。</li>
<li>模型：处理。</li>
<li>视图：展示。</li>
<li>控制器：接受。</li>
<li>流程：控制器<strong>接受</strong>用户发来的请求，调用相应模型<strong>处理</strong>逻辑，然后返回数据给控制器，控制器调用相应视图<strong>展示</strong>结果给用户。</li>
</ul>
<h3 id="SpringMVC工作流程"><a href="#SpringMVC工作流程" class="headerlink" title="SpringMVC工作流程"></a>SpringMVC工作流程</h3><p><img src="/images/springMVCWorkActivity.png" alt="SpringMVC工作流程图.jpg"></p>
<ol>
<li>客户端请求提交到DispatcherServlet </li>
<li>由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller</li>
<li>DispatcherServlet将请求提交到Controller</li>
<li>Controller调用业务逻辑处理后，返回ModelAndView  </li>
<li>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图 </li>
<li>视图负责将结果显示到客户端</li>
</ol>
<h3 id="strus2与Spring-MVC的区别"><a href="#strus2与Spring-MVC的区别" class="headerlink" title="strus2与Spring MVC的区别"></a>strus2与Spring MVC的区别</h3><ol>
<li>Struts2是类级别上的拦截，一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文。而且Struts过滤后是去Struts配置文件中找Action，而SpringMVC过滤后是去controller中找对应于@RequestMapping注解的url绑定的方法。</li>
<li>因为拦截器原因，导致Struts2的action比较乱，因为它要定义属性来获取请求中参数的数据，而属性在一个类的方法间是共享的（方法间不能独享request、response数据），所以会有点乱。而SpringMVC中请求参数与controller中方法的形参自动配对（在名字相同，或请求参数与形参的属性名相同，或通过@RequestParam注解指定条件下会自动将请求参数的值赋给形参）方法间可以独享request、response数据。</li>
<li>SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。</li>
</ol>
<h3 id="SpringMVC常用参数绑定注解"><a href="#SpringMVC常用参数绑定注解" class="headerlink" title="SpringMVC常用参数绑定注解"></a>SpringMVC常用参数绑定注解</h3><ol>
<li>@RequestParam</li>
<li>@RequestBody</li>
<li>@RequestHeader </li>
<li>@CookieValue</li>
<li>@PathVariable</li>
</ol>
<h3 id="SpringMVC怎样设定重定向和转发的？"><a href="#SpringMVC怎样设定重定向和转发的？" class="headerlink" title="SpringMVC怎样设定重定向和转发的？"></a>SpringMVC怎样设定重定向和转发的？</h3><ol>
<li>在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name=jianshu”</li>
<li>在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:<a href="http://www.baidu.com&quot;" target="_blank" rel="noopener">http://www.baidu.com&quot;</a></li>
</ol>
<h3 id="SpringIOC容器"><a href="#SpringIOC容器" class="headerlink" title="SpringIOC容器"></a>SpringIOC容器</h3><p>Spring IOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期，在Spring中BeanFactory是IOC容器的实际代表者。</p>
<h3 id="BeanFactory-接口和-ApplicationContext-接口有什么区别-？"><a href="#BeanFactory-接口和-ApplicationContext-接口有什么区别-？" class="headerlink" title="BeanFactory 接口和 ApplicationContext 接口有什么区别 ？"></a>BeanFactory 接口和 ApplicationContext 接口有什么区别 ？</h3><ol>
<li>ApplicationContext 接口继承BeanFactory接口，Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, ApplicationContext是会在加载配置文件时初始化Bean。</li>
<li>ApplicationContext是对BeanFactory扩展，它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现。<br>开发中基本都在使用ApplicationContext, web项目使用WebApplicationContext ，很少用到BeanFactory。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;applicationContext.xml&quot;));</span><br><span class="line">IHelloService helloService = (IHelloService) beanFactory.getBean(&quot;helloService&quot;);</span><br><span class="line">helloService.sayHello();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="IOC、DI"><a href="#IOC、DI" class="headerlink" title="IOC、DI"></a>IOC、DI</h3><ul>
<li>IOC（Inversion of Control）：由IOC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</li>
<li>DI（Dependency Injection）：被注入对象依赖IOC容器配置依赖对象。</li>
</ul>
<h3 id="依赖注入的几种方式"><a href="#依赖注入的几种方式" class="headerlink" title="依赖注入的几种方式"></a>依赖注入的几种方式</h3><ol>
<li>set注入<br>控制层代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private OrderServiceImp orderService;</span><br><span class="line">    </span><br><span class="line">public void setOrderService(OrderServiceImp orderService) &#123;</span><br><span class="line">       this.orderService = orderService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Spring配置XML文件：其中配置声明OrderAction类存在属性orderService。程序运行时候，会将已经实例化的orderService对象调用setOrderService方式注入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;orderService&quot; ref=&quot;orderService&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>构造器注入<br>控制层代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private OrderServiceImp orderService;</span><br><span class="line">    </span><br><span class="line">public OrderAction(OrderServiceImp orderService) &#123;</span><br><span class="line">        this.orderService = orderService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Spring配置XML文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name=&quot;orderAction&quot; class=&quot;com.pec.action.OrderAction&quot;&gt;</span><br><span class="line">      &lt;constructor-arg ref=&quot;orderService&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean name=&quot;orderService&quot; class=&quot;com.pec.service.imp.OrderServiceImp&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>注解注入</li>
</ol>
<h3 id="Spring中bean实例化有几种方式？"><a href="#Spring中bean实例化有几种方式？" class="headerlink" title="Spring中bean实例化有几种方式？"></a>Spring中bean实例化有几种方式？</h3><ol>
<li>使用类构造器实例化(默认无参数)<bean id="bean1" class="cn.jianshu.Bean1"></bean></li>
<li>静态工厂<bean id="bean2" class="cn.jianshu.Bean2Factory" factory-method="getBean2"></bean></li>
<li>实例工厂<bean id="bean3Factory" class="cn.jianshu.Bean3Factory"></bean><br><bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3"></bean>

</li>
</ol>
<h3 id="简单说下Bean的生命周期"><a href="#简单说下Bean的生命周期" class="headerlink" title="简单说下Bean的生命周期"></a>简单说下Bean的生命周期</h3><ol>
<li>bean定义</li>
<li>bean初始化<br>有两种方式初始化:<ol>
<li>在配置文件中通过指定init-method属性来完成</li>
<li>实现org.springframwork.beans.factory.InitializingBean接口</li>
</ol>
</li>
<li>bean调用<br>三种方式获得bean实例（见上题）</li>
<li>bean销毁<br>有两种方式销毁:<ol>
<li>使用配置文件指定的destroy-method属性</li>
<li>实现org.springframwork.bean.factory.DisposeableBean接口<br>**注意：<br>在配置 <bean> 元素，通过 init-method 指定Bean的初始化方法，通过 destroy-method 指定Bean销毁方法<br>&lt;beanid=”lifeCycleBean”class=”cn.jianshu.LifeCycleBean”init-method=”setup”destroy-method=”teardown”&gt;</bean><ul>
<li>destroy-method 只对 scope=”singleton” 有效 </li>
<li>销毁方法，必须关闭ApplicationContext对象(手动调用)，才会被调用<br>ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(“applicationContext.xml”);<br>applicationContext.close();**</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><ul>
<li>singleton<br>当一个bean的作用域为singleton, 那么Spring IoC容器中只会存在一个共享的bean实例，并且所有对bean的请求，只要id与该bean定义相匹配，则只会返回bean的同一实例。</li>
<li>prototype<br>Prototype作用域的bean会导致在每次对该bean请求（将其注入到另一个bean中，或者以程序的方式调用容器的getBean() 方法）时都会创建一个新的bean实例。根据经验，对所有有状态的bean应该使用prototype作用域，而对无状态的bean则应该使用 singleton作用域。</li>
<li>request<br>在一次HTTP请求中，一个bean定义对应一个实例；即每次HTTP请求将会有各自的bean实例， 它们依据某个bean定义创建而成。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>session<br>在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
<li>global session<br>在一个全局的HTTP Session中，一个bean定义对应一个实例。典型情况下，仅在使用portlet context的时候有效。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li>
</ul>
<h3 id="AOP的理解"><a href="#AOP的理解" class="headerlink" title="AOP的理解"></a>AOP的理解</h3><ul>
<li>面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足，除了类（classes）以外，AOP提供了切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理。</li>
<li>Spring的一个关键的组件就是AOP框架，可以自由选择是否使用AOP 提供声明式企业服务，特别是为了替代EJB声明式服务。最重要的服务是声明性事务管理，这个服务建立在Spring的抽象事物管理之上。允许用户实现自定义切面，用AOP来完善OOP的使用,可以把Spring AOP看作是对Spring的一种增强。<br><img src="/images/aopComprehend.png" alt="AOP的理解图.png"></li>
</ul>
<h3 id="Spring里面的applicationContext-xml文件能不能改成其他名字？"><a href="#Spring里面的applicationContext-xml文件能不能改成其他名字？" class="headerlink" title="Spring里面的applicationContext.xml文件能不能改成其他名字？"></a>Spring里面的applicationContext.xml文件能不能改成其他名字？</h3><p>ContextLoaderListener是一个ServletContextListener, 它在你的web应用启动的时候初始化。缺省情况下， 它会在WEB-INF/applicationContext.xml文件找Spring的配置。 你可以通过定义一个<context-param>元素名字为”contextConfigLocation”来改变Spring配置文件的 位置。示例如下： </context-param></p>
<p><listener><br>    <listener-class>org.springframework.web.context.ContextLoaderListener<br>        <context-param><br>         <param-name>contextConfigLocation</param-name><br>         <param-value>/WEB-INF/jianshu.xml</param-value><br>        </context-param><br>    </listener-class><br></listener> </p>
<h3 id="Spring如何处理线程并发问题？"><a href="#Spring如何处理线程并发问题？" class="headerlink" title="Spring如何处理线程并发问题？"></a>Spring如何处理线程并发问题？</h3><p>Spring使用ThreadLocal解决线程安全问题<br>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。<br><strong>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</strong><br>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。<br>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。<br>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。<br><strong>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</strong></p>
<h3 id="如何解决GET、POST请求中文乱码问题？"><a href="#如何解决GET、POST请求中文乱码问题？" class="headerlink" title="如何解决GET、POST请求中文乱码问题？"></a>如何解决GET、POST请求中文乱码问题？</h3><h5 id="GET请求中文乱码问题解决"><a href="#GET请求中文乱码问题解决" class="headerlink" title="GET请求中文乱码问题解决"></a>GET请求中文乱码问题解决</h5><ul>
<li><p>重新编码参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name= new String(request.getParamter(&quot;name&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改tomcat中server.xml的配置 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; URIEncoding=&quot;utf-8&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="POST请求中文乱码问题解决"><a href="#POST请求中文乱码问题解决" class="headerlink" title="POST请求中文乱码问题解决"></a>POST请求中文乱码问题解决</h5><ul>
<li>web.xml中配置字符编码过滤器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="过滤器、监听器、拦截器"><a href="#过滤器、监听器、拦截器" class="headerlink" title="过滤器、监听器、拦截器"></a>过滤器、监听器、拦截器</h3><h5 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h5><p>所谓过滤器顾名思义是用来过滤的，Java的过滤器能够为我们提供系统级别的过滤，也就是说，能过滤所有的web请求，这一点，是拦截器无法做到的。在Java Web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或<br>者struts的action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者struts的action前统一设置字符集，或者去除掉一些非法字符（聊天室经常用到的，一些骂人的话）。filter 流程是线性的，url传来之后，检查之后，可保持原来的流程继续向下执行，被下一个filter, servlet接收。</p>
<h5 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h5><p>Java的监听器，也是系统级别的监听。监听器随web应用的启动而启动。Java的监听器在c/s模式里面经常用到，它会对特定的事件产生产生一个处理。监听在很多模式下用到，比如说观察者模式，就是一个使用监听器来实现的，在比如统计网站的在线人数。又比如struts2可以用监听来启动。Servlet监听器用于监听一些重要事件的发生，监听器对象可以在事情发生前、发生后可以做一些必要的处理。</p>
<h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p>java里的拦截器提供的是非系统级别的拦截，也就是说，就覆盖面来说，拦截器不如过滤器强大，但是更有针对性。Java中的拦截器是基于Java反射机制实现的，更准确的划分，应该是基于JDK实现的动态代理。它依赖于具体的接口，在运行期间动态生成字节码。拦截器是动态拦截Action调用的对象，它提供了一种机制可以使开发者在一个Action执行的前后执行一段代码，也可以在一个Action执行前阻止其执行，同时也提供了一种可以提取Action中可重用部分代码的方式。在AOP中，拦截器用于在某个方法或者字段被访问之前，进行拦截然后再之前或者之后加入某些操作。java的拦截器主要是用在插件上，扩展件上比如Hibernate Spring Struts2等，有点类似面向切片的技术，在用之前先要在配置文件即xml，文件里声明一段的那个东西。</p>
<h3 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h3><ol>
<li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li>
<li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li>
<li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li>
<li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li>
<li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li>
<li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li>
<li>拦截器需要在Spring配置文件中配置，过滤器只需要在web.xml中配置</li>
</ol>
<h3 id="为什么要有事务传播行为？"><a href="#为什么要有事务传播行为？" class="headerlink" title="为什么要有事务传播行为？"></a>为什么要有事务传播行为？</h3><p><img src="/images/whyTransactionPropagation.png" alt="为什么要有事务传播行为图.png"></p>
<h3 id="spring管理事务有几种方式？"><a href="#spring管理事务有几种方式？" class="headerlink" title="spring管理事务有几种方式？"></a>spring管理事务有几种方式？</h3><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置(推荐使用)<br>声明式事务又分为两种：<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
</li>
</ol>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><img src="/images/transactionPic.png" alt="事务图.png"></p>
<h3 id="‘-’和’-’的区别是什么？"><a href="#‘-’和’-’的区别是什么？" class="headerlink" title="‘#{}’和’${}’的区别是什么？"></a>‘#{}’和’${}’的区别是什么？</h3><p>‘#{}’是预编译处理，${}是字符串替换。<br>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理${}时，就是把${}替换成变量的值。<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>
<h3 id="一对一、一对多关联查询"><a href="#一对一、一对多关联查询" class="headerlink" title="一对一、一对多关联查询"></a>一对一、一对多关联查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;com.jianshu.userMapper&quot;&gt;  </span><br><span class="line">    &lt;!--association  一对一关联查询 --&gt;  </span><br><span class="line">    &lt;select id=&quot;getClass&quot; parameterType=&quot;int&quot; resultMap=&quot;ClassesResultMap&quot;&gt;  </span><br><span class="line">        select * from class c,teacher t where c.teacher_id=t.t_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    &lt;/select&gt;  </span><br><span class="line"> </span><br><span class="line">    &lt;resultMap type=&quot;com.jianshu.Classes&quot; id=&quot;ClassesResultMap&quot;&gt;  </span><br><span class="line">        &lt;!-- 实体类的字段名和数据表的字段名映射 --&gt;  </span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;  </span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;c_name&quot;/&gt;  </span><br><span class="line">        &lt;association property=&quot;teacher&quot; javaType=&quot;com.jianshu.Teacher&quot;&gt;  </span><br><span class="line">            &lt;id property=&quot;id&quot; column=&quot;t_id&quot;/&gt;  </span><br><span class="line">            &lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;  </span><br><span class="line">        &lt;/association&gt;  </span><br><span class="line">    &lt;/resultMap&gt;  </span><br><span class="line"></span><br><span class="line">    &lt;!--collection  一对多关联查询 --&gt;  </span><br><span class="line">    &lt;select id=&quot;getClass2&quot; parameterType=&quot;int&quot; resultMap=&quot;ClassesResultMap2&quot;&gt;  </span><br><span class="line">        select * from class c,teacher t,student s where c.teacher_id=t.t_id and c.c_id=s.class_id and c.c_id=#&#123;id&#125;  </span><br><span class="line">    &lt;/select&gt;  </span><br><span class="line"> </span><br><span class="line">    &lt;resultMap type=&quot;com.jianshu.Classes&quot; id=&quot;ClassesResultMap2&quot;&gt;  </span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;c_id&quot;/&gt;  </span><br><span class="line">        &lt;result property=&quot;name&quot; column=&quot;c_name&quot;/&gt;  </span><br><span class="line">        &lt;association property=&quot;teacher&quot; javaType=&quot;com.jianshu.Teacher&quot;&gt;  </span><br><span class="line">            &lt;id property=&quot;id&quot; column=&quot;t_id&quot;/&gt;  </span><br><span class="line">            &lt;result property=&quot;name&quot; column=&quot;t_name&quot;/&gt;  </span><br><span class="line">        &lt;/association&gt;  </span><br><span class="line"> </span><br><span class="line">        &lt;collection property=&quot;student&quot; ofType=&quot;com.jianshu.Student&quot;&gt;  </span><br><span class="line">            &lt;id property=&quot;id&quot; column=&quot;s_id&quot;/&gt;  </span><br><span class="line">            &lt;result property=&quot;name&quot; column=&quot;s_name&quot;/&gt;  </span><br><span class="line">        &lt;/collection&gt;  </span><br><span class="line">    &lt;/resultMap&gt;  </span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<h3 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h3><ul>
<li>MyBatis的缓存分为一级缓存和二级缓存。</li>
<li>一级缓存，SqlSession级别，默认开启。</li>
<li>二级缓存，namespace级别，需手动配置和开启。</li>
</ul>
<ol>
<li>总配置文件开启二级缓存。</li>
<li>映射文件添加<cache>标签。</cache></li>
<li>实体类实现序列化接口。</li>
</ol>
<h3 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><p>核心注解是启动类上的@SpringBootApplication<br>它由以下四个注解组成：</p>
<ol>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能。</li>
<li>@SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</li>
<li>@ComponentScan：Spring组件扫描。</li>
</ol>
<h3 id="SpringCloud五大组件"><a href="#SpringCloud五大组件" class="headerlink" title="SpringCloud五大组件"></a>SpringCloud五大组件</h3><ol>
<li>服务发现<br>Netflix Eureka</li>
<li>客户端负载均衡<br>Netflix Ribbon</li>
<li>断路器<br>Netflix Hystri</li>
<li>服务网关<br>Netflix Zuul</li>
<li>分布式配置<br>Spring Cloud Config</li>
</ol>
<h3 id="dubbo支持的通信协议"><a href="#dubbo支持的通信协议" class="headerlink" title="dubbo支持的通信协议"></a>dubbo支持的通信协议</h3><ol>
<li>dubbo://</li>
<li>rmi://</li>
<li>hessian://</li>
<li>http://</li>
<li>webservice://</li>
<li>thrift://</li>
<li>memcached://</li>
<li>redis://<br>底层采用socket进行通信</li>
</ol>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p>
<h3 id="分布式环境下的session处理策略"><a href="#分布式环境下的session处理策略" class="headerlink" title="分布式环境下的session处理策略"></a>分布式环境下的session处理策略</h3><ol>
<li><p>粘性session</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream mycluster&#123;</span><br><span class="line">    #这里添加的是上面启动好的两台Tomcat服务器</span><br><span class="line">    ip_hash;#粘性Session</span><br><span class="line">     server 192.168.22.229:8080 weight=1;</span><br><span class="line">     server 192.168.22.230:8080 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器session复制</p>
</li>
<li>session共享机制<ol>
<li>粘性session处理方式<br><img src="https://upload-images.jianshu.io/upload_images/15728924-51f17c109ecd6d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
<li>非粘性session处理方式<br><img src="https://upload-images.jianshu.io/upload_images/15728924-ede8cb7124cbe302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ol>
</li>
<li>session持久化到数据库</li>
<li>terracotta实现session复制<br><img src="https://upload-images.jianshu.io/upload_images/15728924-20378fb6e090d348.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ol>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>ByteTCC、LCN<br><strong>阿里分布式事务框架GTS开源了一个免费社区版Fescar</strong><br><img src="https://upload-images.jianshu.io/upload_images/15728924-ce716f6d0eaa805b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="FESCAR管理分布式事务的典型生命周期图.png"></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h5 id="基于数据库做分布式锁"><a href="#基于数据库做分布式锁" class="headerlink" title="基于数据库做分布式锁"></a>基于数据库做分布式锁</h5><ol>
<li>基于表主键唯一做分布式锁</li>
<li>基于表字段版本号做分布式锁</li>
<li><p>基于数据库排他锁做分布式锁</p>
<h5 id="基于-Redis-做分布式锁"><a href="#基于-Redis-做分布式锁" class="headerlink" title="基于 Redis 做分布式锁"></a>基于 Redis 做分布式锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class RedisTool &#123;</span><br><span class="line"></span><br><span class="line">    private static final String LOCK_SUCCESS = &quot;OK&quot;;</span><br><span class="line">    private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;</span><br><span class="line">    private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取分布式锁</span><br><span class="line">     * @param jedis Redis客户端</span><br><span class="line">     * @param lockKey 锁</span><br><span class="line">     * @param requestId 请求标识</span><br><span class="line">     * @param expireTime 超期时间</span><br><span class="line">     * @return 是否获取成功</span><br><span class="line">     */</span><br><span class="line">    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123;</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        if (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RedisTool &#123;</span><br><span class="line"></span><br><span class="line">    private static final Long RELEASE_SUCCESS = 1L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放分布式锁</span><br><span class="line">     * @param jedis Redis客户端</span><br><span class="line">     * @param lockKey 锁</span><br><span class="line">     * @param requestId 请求标识</span><br><span class="line">     * @return 是否释放成功</span><br><span class="line">     */</span><br><span class="line">    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) &#123;</span><br><span class="line"></span><br><span class="line">        String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        if (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 REDIS 的 SETNX()、EXPIRE() 方法做分布式锁</p>
</li>
<li>基于 REDIS 的 SETNX()、GET()、GETSET()方法做分布式锁</li>
<li>基于 REDLOCK 做分布式锁</li>
<li>基于 REDISSON 做分布式锁<h5 id="基于-ZooKeeper-做分布式锁"><a href="#基于-ZooKeeper-做分布式锁" class="headerlink" title="基于 ZooKeeper 做分布式锁"></a>基于 ZooKeeper 做分布式锁</h5><h5 id="基于-Consul-做分布式锁"><a href="#基于-Consul-做分布式锁" class="headerlink" title="基于 Consul 做分布式锁"></a>基于 Consul 做分布式锁</h5></li>
</ol>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p><img src="https://upload-images.jianshu.io/upload_images/15728924-0804d33e42177d8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fanout"><br><img src="https://upload-images.jianshu.io/upload_images/15728924-c8c3922adc477ba6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="direct"><br><img src="https://upload-images.jianshu.io/upload_images/15728924-3585c42e9e9a5775.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="topic"><br><img src="https://upload-images.jianshu.io/upload_images/15728924-512f974be2bc4e00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="headers"></p>
<h3 id="MyISAM与InnoDB的区别"><a href="#MyISAM与InnoDB的区别" class="headerlink" title="MyISAM与InnoDB的区别"></a>MyISAM与InnoDB的区别</h3><ol>
<li>存储结构</li>
<li>存储空间</li>
<li>可移值性、备份、恢复</li>
<li>事务支持</li>
<li>AUTO_INCREMENT</li>
<li>表锁差异</li>
<li>全文索引</li>
<li>表主键</li>
<li>表的具体行数　</li>
<li>CURD操作</li>
<li>外键<br>MySQL默认采用的是MyISAM。</li>
</ol>
<h3 id="索引底层实现原理"><a href="#索引底层实现原理" class="headerlink" title="索引底层实现原理"></a>索引底层实现原理</h3><ol>
<li>索引的本质<br><img src="https://upload-images.jianshu.io/upload_images/15728924-0ecfa37339642367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
<li>二叉树<br><img src="https://upload-images.jianshu.io/upload_images/15728924-bf0354c0a8ec9766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
<li>B树<br><img src="https://upload-images.jianshu.io/upload_images/15728924-b9d3858789d6c2cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>4.B+树<br><img src="https://upload-images.jianshu.io/upload_images/15728924-4e31ae1172b3d21e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
<li>带有顺序访问指针的B+Tree<br><img src="https://upload-images.jianshu.io/upload_images/15728924-f45dab1125d8c380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ol>
<h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p>避免全表扫描，改为索引扫描。</p>
<ol>
<li>适当的索引。</li>
<li>尽量不要有空判断的语句，因为空判断将导致全表扫描，而不是索引扫描。尽量不要有空判断的语句，因为空判断将导致全表扫描，而不是索引扫描。 对于空判断这种情况，可以考虑对这个列创建数据库默认值。</li>
<li>尽量不要使用不等于条件，因为，这会导致全表扫描，对于不等于这种情况，考虑改为范围查询解决。</li>
<li>尽量不要使用or条件，因为，这会导致全表扫描，对于or这种情况，可以改为 分别查询，然后 union all。</li>
<li>尽量不要使用左右模糊查询，因为，这会导致全表扫描， 对于左右模糊查询的情况，试着改为右侧模糊查询，这样是可以索引查找的。</li>
<li>尽量不要在执行算数运算后的比较，因为，函数、算术运算或其他表达式运算通常将导致全表扫描，对于这种情况，可以考虑冗余部分数据到表中。</li>
<li>尽量使用exists代替in。</li>
<li>尽量避免一次性返回大数据量，可以考虑分页返回。</li>
</ol>
<h3 id="union与union-all"><a href="#union与union-all" class="headerlink" title="union与union all"></a>union与union all</h3><ol>
<li>union :得到两个查询结果的并集，并且自动<strong>去掉重复行</strong>。不会排序。 </li>
<li>union all:得到两个查询结果的并集，不会去掉重复行。也不会排序。 </li>
</ol>
<h3 id="Oracle与MySQL分页查询的写法"><a href="#Oracle与MySQL分页查询的写法" class="headerlink" title="Oracle与MySQL分页查询的写法"></a>Oracle与MySQL分页查询的写法</h3><ol>
<li><p>Oracle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM</span><br><span class="line">		(</span><br><span class="line">				SELECT A. *, ROWNUM RN</span><br><span class="line">				FROM(SELECT * FROM TABLE_NAME)A</span><br><span class="line">				WHERE ROWNUM &lt;= 40</span><br><span class="line">		)</span><br><span class="line">WHERE RN &gt;=21</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM TABLE LIMIT 5, 10;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="SQL小贴士"><a href="#SQL小贴士" class="headerlink" title="SQL小贴士"></a>SQL小贴士</h3><ul>
<li>执行顺序<br>from-&gt;where-&gt;group by-&gt;having-&gt;select-&gt;order by</li>
<li>HAVING 子句<br>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。</li>
<li>union去重，union all 不去重。</li>
<li>case when then else end</li>
<li>当前时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT NOW(),CURDATE(),CURTIME() FROM DUAL</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>结果：<br>NOW()|CURDATE()|CURTIME()<br>:-:|:-:|:-:<br>2008-12-29 16:25:46|2008-12-29|16:25:46</p>
<ul>
<li>时间间隔<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT DATEDIFF(&apos;2017-08-08&apos;,&apos;2017-08-17&apos;);</span><br><span class="line">+-------------------------------------+</span><br><span class="line">| DATEDIFF(&apos;2017-08-08&apos;,&apos;2017-08-17&apos;) |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">|                                  -9 |</span><br><span class="line">+-------------------------------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="查看数据库引擎命令"><a href="#查看数据库引擎命令" class="headerlink" title="查看数据库引擎命令"></a>查看数据库引擎命令</h3><p>show variables like ‘%storage_engine%’;</p>
<h3 id="Linux下查询所有tomcat进程命令"><a href="#Linux下查询所有tomcat进程命令" class="headerlink" title="Linux下查询所有tomcat进程命令"></a>Linux下查询所有tomcat进程命令</h3><p>ps -ef|grep tomcat</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/面试/" rel="tag"># 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/18/二分查找/" rel="next" title="二分查找">
                <i class="fa fa-chevron-left"></i> 二分查找
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/18/stack/" rel="prev" title="stack">
                stack <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/p.jpg" alt="Fland.Ho">
            
              <p class="site-author-name" itemprop="name">Fland.Ho</p>
              <div class="site-description motion-element" itemprop="description">target.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">84</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">121</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象的三大特征"><span class="nav-number">1.</span> <span class="nav-text">面向对象的三大特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象和面向过程的区别"><span class="nav-number">2.</span> <span class="nav-text">面向对象和面向过程的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#面向过程："><span class="nav-number">2.0.1.</span> <span class="nav-text">面向过程：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#面向对象："><span class="nav-number">2.0.2.</span> <span class="nav-text">面向对象：</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#Java代码的运行"><span class="nav-number">3.</span> <span class="nav-text">Java代码的运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK与JRE"><span class="nav-number">4.</span> <span class="nav-text">JDK与JRE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载（overloading）与重写（overriding）"><span class="nav-number">5.</span> <span class="nav-text">重载（overloading）与重写（overriding）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals与-的区别"><span class="nav-number">6.</span> <span class="nav-text">equals与==的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String、StringBuff、StringBuild的区别"><span class="nav-number">7.</span> <span class="nav-text">String、StringBuff、StringBuild的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类成员访问修饰符"><span class="nav-number">8.</span> <span class="nav-text">类成员访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#”static”关键字是什么意思？Java中是否可以覆盖-override-一个static方法？"><span class="nav-number">9.</span> <span class="nav-text">”static”关键字是什么意思？Java中是否可以覆盖(override)一个static方法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java语言支持的8中基本数据类型对应的长度、对应的包装类"><span class="nav-number">10.</span> <span class="nav-text">Java语言支持的8中基本数据类型对应的长度、对应的包装类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口和抽象类的区别"><span class="nav-number">11.</span> <span class="nav-text">接口和抽象类的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final、finally、finalize"><span class="nav-number">12.</span> <span class="nav-text">final、finally、finalize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#native方法是什么？"><span class="nav-number">13.</span> <span class="nav-text">native方法是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何原地交换两个变量的值？"><span class="nav-number">14.</span> <span class="nav-text">如何原地交换两个变量的值？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用最有效率的方法计算-2-乘以-8"><span class="nav-number">15.</span> <span class="nav-text">用最有效率的方法计算 2 乘以 8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合框架中的泛型有什么优点？"><span class="nav-number">16.</span> <span class="nav-text">集合框架中的泛型有什么优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-集合框架的基础接口有哪些？"><span class="nav-number">17.</span> <span class="nav-text">Java 集合框架的基础接口有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator-和-ListIterator-的区别是什么？"><span class="nav-number">18.</span> <span class="nav-text">Iterator 和 ListIterator 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-中的-HashMap-的工作原理是什么？"><span class="nav-number">19.</span> <span class="nav-text">Java 中的 HashMap 的工作原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-和-HashTable-有什么区别？"><span class="nav-number">20.</span> <span class="nav-text">HashMap 和 HashTable 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的并发度是什么？"><span class="nav-number">21.</span> <span class="nav-text">ConcurrentHashMap的并发度是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？"><span class="nav-number">22.</span> <span class="nav-text">快速失败（fail-fast）和安全失败（fail-safe）的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#值传递与引用传递"><span class="nav-number">23.</span> <span class="nav-text">值传递与引用传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是线程？线程和进程区别在哪？"><span class="nav-number">24.</span> <span class="nav-text">什么是线程？线程和进程区别在哪？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java中用到的线程调度算法是什么？"><span class="nav-number">25.</span> <span class="nav-text">Java中用到的线程调度算法是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现多线程？"><span class="nav-number">26.</span> <span class="nav-text">如何实现多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用Thread还是用Runnable？"><span class="nav-number">27.</span> <span class="nav-text">用Thread还是用Runnable？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread-类中的start-和-run-方法有什么区别？"><span class="nav-number">28.</span> <span class="nav-text">Thread 类中的start() 和 run() 方法有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable和Callable有什么不同？"><span class="nav-number">29.</span> <span class="nav-text">Runnable和Callable有什么不同？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用线程池"><span class="nav-number">30.</span> <span class="nav-text">常用线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep和wait的区别"><span class="nav-number">31.</span> <span class="nav-text">sleep和wait的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何强制启动一个线程？"><span class="nav-number">32.</span> <span class="nav-text">如何强制启动一个线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile关键字的作用是什么？"><span class="nav-number">33.</span> <span class="nav-text">volatile关键字的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是乐观锁和悲观锁？"><span class="nav-number">34.</span> <span class="nav-text">什么是乐观锁和悲观锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享锁和排它锁"><span class="nav-number">35.</span> <span class="nav-text">共享锁和排它锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重入锁、可中断锁、公平锁、读写锁"><span class="nav-number">36.</span> <span class="nav-text">可重入锁、可中断锁、公平锁、读写锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#表锁、页锁、行锁"><span class="nav-number">37.</span> <span class="nav-text">表锁、页锁、行锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized与lock的区别"><span class="nav-number">38.</span> <span class="nav-text">synchronized与lock的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在静态方法和非静态方法上加-Synchronized的区别"><span class="nav-number">38.1.</span> <span class="nav-text">在静态方法和非静态方法上加 Synchronized的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk1-8新特性"><span class="nav-number">39.</span> <span class="nav-text">jdk1.8新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见算法"><span class="nav-number">40.</span> <span class="nav-text">常见算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见数据结构"><span class="nav-number">41.</span> <span class="nav-text">常见数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用设计模式"><span class="nav-number">42.</span> <span class="nav-text">常用设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对称加密与非对称加密"><span class="nav-number">43.</span> <span class="nav-text">对称加密与非对称加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何谓RESTful？"><span class="nav-number">44.</span> <span class="nav-text">何谓RESTful？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#何谓MVC？"><span class="nav-number">45.</span> <span class="nav-text">何谓MVC？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC工作流程"><span class="nav-number">46.</span> <span class="nav-text">SpringMVC工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#strus2与Spring-MVC的区别"><span class="nav-number">47.</span> <span class="nav-text">strus2与Spring MVC的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC常用参数绑定注解"><span class="nav-number">48.</span> <span class="nav-text">SpringMVC常用参数绑定注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC怎样设定重定向和转发的？"><span class="nav-number">49.</span> <span class="nav-text">SpringMVC怎样设定重定向和转发的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringIOC容器"><span class="nav-number">50.</span> <span class="nav-text">SpringIOC容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-接口和-ApplicationContext-接口有什么区别-？"><span class="nav-number">51.</span> <span class="nav-text">BeanFactory 接口和 ApplicationContext 接口有什么区别 ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IOC、DI"><span class="nav-number">52.</span> <span class="nav-text">IOC、DI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖注入的几种方式"><span class="nav-number">53.</span> <span class="nav-text">依赖注入的几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring中bean实例化有几种方式？"><span class="nav-number">54.</span> <span class="nav-text">Spring中bean实例化有几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单说下Bean的生命周期"><span class="nav-number">55.</span> <span class="nav-text">简单说下Bean的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean的作用域"><span class="nav-number">56.</span> <span class="nav-text">Bean的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP的理解"><span class="nav-number">57.</span> <span class="nav-text">AOP的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring里面的applicationContext-xml文件能不能改成其他名字？"><span class="nav-number">58.</span> <span class="nav-text">Spring里面的applicationContext.xml文件能不能改成其他名字？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring如何处理线程并发问题？"><span class="nav-number">59.</span> <span class="nav-text">Spring如何处理线程并发问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何解决GET、POST请求中文乱码问题？"><span class="nav-number">60.</span> <span class="nav-text">如何解决GET、POST请求中文乱码问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#GET请求中文乱码问题解决"><span class="nav-number">60.0.1.</span> <span class="nav-text">GET请求中文乱码问题解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#POST请求中文乱码问题解决"><span class="nav-number">60.0.2.</span> <span class="nav-text">POST请求中文乱码问题解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤器、监听器、拦截器"><span class="nav-number">61.</span> <span class="nav-text">过滤器、监听器、拦截器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#过滤器"><span class="nav-number">61.0.1.</span> <span class="nav-text">过滤器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#监听器"><span class="nav-number">61.0.2.</span> <span class="nav-text">监听器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拦截器"><span class="nav-number">61.0.3.</span> <span class="nav-text">拦截器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拦截器和过滤器的区别"><span class="nav-number">62.</span> <span class="nav-text">拦截器和过滤器的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要有事务传播行为？"><span class="nav-number">63.</span> <span class="nav-text">为什么要有事务传播行为？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring管理事务有几种方式？"><span class="nav-number">64.</span> <span class="nav-text">spring管理事务有几种方式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务"><span class="nav-number">65.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#‘-’和’-’的区别是什么？"><span class="nav-number">66.</span> <span class="nav-text">‘#{}’和’${}’的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一对一、一对多关联查询"><span class="nav-number">67.</span> <span class="nav-text">一对一、一对多关联查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyBatis缓存"><span class="nav-number">68.</span> <span class="nav-text">MyBatis缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><span class="nav-number">69.</span> <span class="nav-text">Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringCloud五大组件"><span class="nav-number">70.</span> <span class="nav-text">SpringCloud五大组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbo支持的通信协议"><span class="nav-number">71.</span> <span class="nav-text">dubbo支持的通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAP理论"><span class="nav-number">72.</span> <span class="nav-text">CAP理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式环境下的session处理策略"><span class="nav-number">73.</span> <span class="nav-text">分布式环境下的session处理策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式事务"><span class="nav-number">74.</span> <span class="nav-text">分布式事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式锁"><span class="nav-number">75.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#基于数据库做分布式锁"><span class="nav-number">75.0.1.</span> <span class="nav-text">基于数据库做分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于-Redis-做分布式锁"><span class="nav-number">75.0.2.</span> <span class="nav-text">基于 Redis 做分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于-ZooKeeper-做分布式锁"><span class="nav-number">75.0.3.</span> <span class="nav-text">基于 ZooKeeper 做分布式锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于-Consul-做分布式锁"><span class="nav-number">75.0.4.</span> <span class="nav-text">基于 Consul 做分布式锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">76.</span> <span class="nav-text">RabbitMQ</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM与InnoDB的区别"><span class="nav-number">77.</span> <span class="nav-text">MyISAM与InnoDB的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引底层实现原理"><span class="nav-number">78.</span> <span class="nav-text">索引底层实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL优化"><span class="nav-number">79.</span> <span class="nav-text">SQL优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union与union-all"><span class="nav-number">80.</span> <span class="nav-text">union与union all</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Oracle与MySQL分页查询的写法"><span class="nav-number">81.</span> <span class="nav-text">Oracle与MySQL分页查询的写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL小贴士"><span class="nav-number">82.</span> <span class="nav-text">SQL小贴士</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查看数据库引擎命令"><span class="nav-number">83.</span> <span class="nav-text">查看数据库引擎命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux下查询所有tomcat进程命令"><span class="nav-number">84.</span> <span class="nav-text">Linux下查询所有tomcat进程命令</span></a></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fland.Ho</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.1</div>



        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/affix.js?v=7.1.1"></script>

  <script src="/js/schemes/pisces.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



  

<script src="https://cdn.bootcdn.net/ajax/libs/valine/1.4.14/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'PhTCuXxsfqCoCIbUKpm7y7vt-gzGzoHsz',
    appKey: '4hCT0uFrIacWy45eyFVEykyo',
    placeholder: '敬请留言……',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn'
  });
</script>




  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
